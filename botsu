def getNo(img):
    # 特徴点の抽出準備
    detector = cv2.AKAZE_create()
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    # 特徴点抽出時に、余白がないとだめだから、その余白の大きさ
    yohaku = 10
    # 文字位置
    position = [725, 734, 743]
    widthNum = 10
    # 図鑑番号のデータ。字が小さすぎて、桁ごとにフォントが違うレベルに字が潰れてたから、各桁ごとに用意
    os.chdir(os.path.dirname(os.path.abspath(__file__)))
    descriptors = [
        [
            np.load("./Descriptors/ZukanNo_0XX.npy"),
            np.load("./Descriptors/ZukanNo_1XX.npy"),
            np.load("./Descriptors/ZukanNo_2XX.npy")
        ],
        [
            np.load("./Descriptors/ZukanNo_X0X.npy"),
            np.load("./Descriptors/ZukanNo_X1X.npy"),
            np.load("./Descriptors/ZukanNo_X2X.npy"),
            np.load("./Descriptors/ZukanNo_X3X.npy"),
            np.load("./Descriptors/ZukanNo_X4X.npy"),
            np.load("./Descriptors/ZukanNo_X5X.npy"),
            np.load("./Descriptors/ZukanNo_X6X.npy"),
            np.load("./Descriptors/ZukanNo_X7X.npy"),
            np.load("./Descriptors/ZukanNo_X8X.npy"),
            np.load("./Descriptors/ZukanNo_X9X.npy")
        ],
        [
            np.load("./Descriptors/ZukanNo_XX0.npy"),
            np.load("./Descriptors/ZukanNo_XX1.npy"),
            np.load("./Descriptors/ZukanNo_XX2.npy"),
            np.load("./Descriptors/ZukanNo_XX3.npy"),
            np.load("./Descriptors/ZukanNo_XX4.npy"),
            np.load("./Descriptors/ZukanNo_XX5.npy"),
            np.load("./Descriptors/ZukanNo_XX6.npy"),
            np.load("./Descriptors/ZukanNo_XX7.npy"),
            np.load("./Descriptors/ZukanNo_XX8.npy"),
            np.load("./Descriptors/ZukanNo_XX9.npy")
        ]
    ]
    ## 2値化
    threshold = 150
    _, img_binary = cv2.threshold(img, threshold, 255, cv2.THRESH_BINARY)

    ## ポケモンの図鑑No.を検出
    img = []
    for i in range(3):
        img_temp = cv2.bitwise_not(img_binary[144 : 161, position[i] : position[i] + widthNum ])
        img_temp = cv2.copyMakeBorder(img_temp, yohaku, yohaku, yohaku,yohaku, cv2.BORDER_CONSTANT,value=[255,255,255])
        img_temp = cv2.resize(img_temp, (int(img_temp.shape[1] * 10), int(img_temp.shape[0] * 10)))
        img.append(img_temp)
    return matchAndPredict(img, descriptors)







    
def matchAndPredict(img, des0to9):
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    detector = cv2.AKAZE_create()
    kp = []
    des = []
    for img_temp in img:
        kp_temp, des_temp = detector.detectAndCompute(img_temp, None)
        kp.append(kp_temp)
        des.append(des_temp)

    result = 0
    for i in range(len(des)):
        score = 0
        predict = 0
        if(len(des0to9) != 10):
            desCurrentKeta = des0to9[i]
        else:
            desCurrentKeta = des0to9
        for j, d in enumerate(desCurrentKeta):
            matches = bf.match(des[i], d)
            if(score < len(matches)):
                score = len(matches)
                predict = j
        result = result + predict * pow(10, len(des) - i - 1)
    return result